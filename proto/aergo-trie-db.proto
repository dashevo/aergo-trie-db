syntax = "proto3";

package org.dash.universeTrieDB.v0;

service UniverseTrieDB {
    // Create a new Trie
    rpc createTrie (CreateTrieRequest) returns (CreateTrieResponse);

    // Drop existing Trie
    rpc dropTrie (DropTrieRequest) returns (DropTrieResponse);

    // Return list of created Tries
    rpc getTriesList(GetTriesListRequest) returns (GetTriesListResponse);

    // Update will recursively go down the tree and split the keys and values
    // according to the side of the tree they belong to:
    // multiple parts of the tree can be simultaneously updated.
    //
    // If update is called several times before Commit, only the last state is committed.
    rpc update(UpdateRequest) returns (UpdateResponse);

    // AtomicUpdate updates the tree with sorted keys and values just like Update
    // But unlike update, if AtomicUpdate is called several times before Commit,
    // all the intermediate states from AtomicUpdate calls will be recorded.
    // This can be useful when authenticating the state of each block,
    // but not committing to the database right away.
    rpc atomicUpdate(AtomicUpdateRequest) returns (AtomicUpdateResponse);

    // Get the value of a key stored in the tree,
    // if a key is default, i.e., not stored, return nil.
    rpc get(GetRequest) returns (GetResponse);

    // Get many values of a keys stored in the tree,
    // if a key is default, i.e., not stored, return nil.
    rpc getMany(GetManyRequest) returns (GetManyResponse);

    // Commit the updated nodes to the storage.
    // When update is called, the new nodes are stored in smt.db.updatedNodes.
    // Commit then stores to disk.
    rpc commit(CommitRequest) returns (CommitResponse);

    // Use the Stash function to revert the update without committing.
    rpc stash(StashRequest) returns (StashResponse);

    // When revert is called, the trees to rollback (between the current tree and toOldRoot)
    // are deleted from the database.
    rpc revert(RevertRequest) returns (RevertResponse);

    // Creates a Merkle proof of inclusion/non-inclusion of the key.
    // The Merkle proof is an array of hashes.
    //
    // If the key is not included, MerkleProof will return false
    // along with the proof leaf on the path of the key.
    //
    // calls MerkleProof func
    rpc getMerkleProof(GetMerkleProofRequest) returns (GetMerkleProofResponse);

    // Creates the same Merkle proof as MerkleProof but compressed using a bitmap
    //
    // calls MerkleProofCompressed func
    rpc getCompressedMerkleProof(GetCompressedMerkleProofRequest) returns (GetCompressedMerkleProofResponse);

    // Creates many compressed Merkle proofs using a bitmap
    //
    // calls MerkleProofCompressed func
    rpc getManyCompressedMerkleProofs(GetManyCompressedMerkleProofsRequest) returns (GetManyCompressedMerkleProofsResponse);

    // Creates a Merkle proof of inclusion/non-inclusion of the key at a given trie root.
    // This is used to query state at a different block than the last one.
    //
    // calls MerkleProofPast func
    rpc getPastMerkleProof(GetPastMerkleProofRequest) returns (GetPastMerkleProofResponse);

    // Verifies that the key-value pair is included in the tree at the current Root.
    rpc verifyInclusion(VerifyInclusionRequest) returns (VerifyInclusionResponse);

    // Verify a proof of non-inclusion.
    //
    // Verifies that a leaf(proofKey, proofValue, height) of empty subtree is on the path
    // of the non-included key.
    rpc verifyNonInclusion(VerifyNonInclusionRequest) returns (VerifyNonInclusionResponse)

    // Verifies a compressed proof of inclusion.
    // ‘length’ is the height of the leaf key-value being verified.
    //
    // calls VerifyInclusionC func
    rpc verifyCompressedInclusion(VerifyCompressedInclusionRequest) returns (VerifyCompressedInclusionResponse);

    // Verify a compressed proof of non-inclusion.
    // Verifies that a leaf (proofKey, proofValue, height) of empty subtree is on the path
    // of the non-included key.
    //
    // calls VerifyNonInclusionC func
    rpc verifyCompressedNonInclusion(VerifyCompressedNonInclusionRequest) returns (VerifyCompressedNonInclusionResponse);
}

//
// Requests and Responses
//

// CreateTrie

message CreateTrieRequest {
    // Trie name: [0-1a-zA-Z_\-]{1, 64}
    string name = 1;

    // The number of tree levels we want to store in cache.
    uint32 cache_height_limit = 2;
}

message CreateTrieResponse {

}

// DropTrie

message DropTrieRequest {
    string name = 1;
}

message DropTrieResponse {

}

// GetTriesList

message GetTriesListRequest {

}

message GetTriesListResponse {
    repeated TrieInfo tries = 1;
}

// Update

message UpdateRequest {
    string trie_name = 1;

    repeated KeyValue keys_values = 2;
}

message UpdateResponse {
    // Updated trie root
    bytes root = 1;
}

// AtomicUpdate

message AtomicUpdateRequest {
    string trie_name = 1;

    repeated KeyValue keys_values = 2;
}

message AtomicUpdateResponse {
    // Updated trie root
    bytes root = 1;
}

// Get

message GetRequest {
     string trie_name = 1;

     bytes key = 2;
}

message GetResponse {
    // Undefined if key is not exists
    bytes value = 1;
}

// GetMany

message GetManyRequest {
    string trie_name = 1;

    repeated bytes keys = 2;
}

message GetManyResponse {
    repeated KeyValue values = 1;
}

// Commit

message CommitRequest {
    string trie_name = 1;
}

message CommitResponse {
    // Committed trie root
    bytes root = 1;
}

// Stash

message StashRequest {
    string trie_name = 1;

    bool rollback_cache = 2;
}

message StashResponse {

}

// Revert

message RevertRequest {
    string trie_name = 1;

    bytes old_root = 2;
}

message RevertResponse {

}

// GetMerkleProof

message GetMerkleProofRequest {
    string trie_name = 1;

    bytes key = 2;
}

message GetMerkleProofResponse {
    MerkleProof merkle_proof = 2;
}

// GetCompressedMerkleProof

message GetCompressedMerkleProofRequest {
    string trie_name = 1;

    bytes key = 2;
}

message GetCompressedMerkleProofResponse {
    MerkleProofCompressed merkle_proof = 1;
}

// GetManyCompressedMerkleProofs

message GetManyCompressedMerkleProofsRequest {
    string trie_name = 1;

    repeated bytes keys = 2;
}

message GetManyCompressedMerkleProofsResponse {
    repeated MerkleProofCompressed merkle_proof = 1;
}


// GetPastMerkleProof

message GetPastMerkleProofRequest {
    string trie_name = 1;

    bytes key = 2;
    bytes root = 3;
}

message GetPastMerkleProofResponse {
    MerkleProof merkle_proof = 1;
}

// VerifyInclusion

message VerifyInclusionRequest {
    string trie_name = 1;

    MerkleProof merkle_proof = 2;
}

message VerifyInclusionResponse {
    bool valid = 1;
}

// VerifyNonInclusion

message VerifyNonInclusionRequest {
    string trie_name = 1;

    bytes key = 2;

    MerkleProof merkle_proof = 3;
}

message VerifyNonInclusionResponse {
    bool valid = 1;
}

// VerifyCompressedInclusion

message VerifyCompressedInclusionRequest {
    string trie_name = 1;

    MerkleProofCompressed merkle_proof = 2;
}

message VerifyCompressedInclusionResponse {
    bool valid = 1;
}

// VerifyCompressedNonInclusion

message VerifyCompressedNonInclusionRequest {
    string trie_name = 1;

    bytes key = 2;

    MerkleProofCompressed merkle_proof = 3;
}

message VerifyCompressedNonInclusionResponse {
    bool valid = 1;
}

// Generic messages

message MerkleProof {
    // True if key exist
    bool included = 1;

    // Merkle proof
    repeated bytes audit_path = 2;

    bytes key = 3;
    bytes value = 4;
}

message MerkleProofCompressed {
    // True if key exist
    bool included = 1;

    // Bitmap with nil values
    bytes bitmap = 2;
    // Merkle proof
    repeated bytes audit_path = 3;

    uint64 height = 4;

    bytes key = 5;
    bytes value = 6;
}

message KeyValue {
    bytes key = 1;
    // Undefined if value is key is not exists
    bytes value = 2;
}

message TrieInfo {
    string name = 1;
    // Trie root
    bytes root = 2;
    // The number if bits in a key
	uint32 trie_height = 3;
	// Counts the nb of db reads in on update
	uint32 load_db_counter = 4;
	// Counts the nb of cache reads in on update
	uint32 load_cache_counter = 5;
    // The number of tree levels stored in cache
    uint32 cache_height_limit = 6;
}